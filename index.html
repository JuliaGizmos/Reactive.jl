<!DOCTYPE html>
<html>
<head>
  <meta name="author" content="Shashi Gowda">
  <meta charset="utf-8">
  <title>Introduction - Reactive.jl</title>
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro:400,700'
        rel='stylesheet' type='text/css'>
  <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/custom.css" rel="stylesheet" type="text/css" media="all">
  <link href="css/hk-pyg.css" rel="stylesheet" type="text/css" media="all">
  <script src="js/jquery-2.0.3.min.js" type="text/javascript"></script>
  <script src="js/bootstrap.min.js" type="text/javascript"></script>
  <script src="js/list.min.js" type="text/javascript"></script>
</head>
<body>
  <div id="topbar" style="z-index: 3">
    <div class="container">
      <div class="row">
        <ul>
          <li><div id="pkgname">Reactive 0.1.7+</div></li>
          <li><a href="http://github.com/JuliaLang/Reactive.jl">Code</a></li>
          <li><a href="http://github.com/JuliaLang/Reactive.jl/issues">Issues</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container" style="z-index: auto">
    <div class="row">
      <div class="col-sm-7">
      <div id="body-content">
<figure>
<img src="Star-On-Machine.jpg" />
</figure>
<p>Reactive.jl is a Julia package for <a href="http://en.wikipedia.org/Reactive_Programming">Reactive Programming</a>. It makes writing event-driven programs simple.</p>
<p>Reactive borrows its design from <a href="http://elm-lang.org/">Elm</a> (see also <a href="http://elm-lang.org/learn/What-is-FRP.elm">Functional Reactive Programming</a>).</p>
<h1 id="getting-started">Getting Started</h1>
<p>To install the latest release of Reactive, run the following in the Julia REPL.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">Pkg.add(<span class="st">&quot;Reactive&quot;</span>)</code></pre>
<p>To start using it, import it:</p>
<pre class="sourceCode julia julia"><code class="sourceCode julia">using Reactive</code></pre>
<h1 id="a-tutorial-introduction">A Tutorial Introduction</h1>
<h2 id="signals">Signals</h2>
<!-- the dot language mapping of signal types:
        input: 'hexagon'
        lift: 'invtrapezium'
        foldp: 'rect'
        sampleOn: 'house'
        constant: 'none'
        dropRepeats: 'doubleoctagon';
        merge: 'invtriangle';
        default: 'ellipse';
-->
<p>The basic currency of Reactive programs is the signal. <code>Signal{T}</code> is an abstract type that represents a time-varying value of type <code>T</code>. You can create, mix and mash <code>Signal</code>s using Reactive.</p>
<p>An <code>Input</code> is the most basic kind of signal: it has no <em>parents</em>--all updates to it are explicitly done through a call to <code>push!</code>.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>
x = Input(<span class="fl">0</span>)
typeof(x)
<span class="co"># =&gt; Input{Int64}</span>
super(Input{<span class="dt">Int64</span>})
<span class="co"># =&gt; Signal{Int64}</span>
x.value
<span class="co"># =&gt; 0</span>
push!(x, <span class="fl">2</span>)
x.value
<span class="co"># =&gt; 2</span></code></pre>
<h2 id="do-you-even-lift">Do you even lift?</h2>
<p>The <code>lift</code> operator can be used to transform one signal into another.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">xsquared = lift(a -&gt; a*a, <span class="dt">Int</span>, x)
typeof(xsquared)
<span class="co"># =&gt; Lift{Int64}</span>
super(Lift{<span class="dt">Int64</span>})
<span class="co"># =&gt; Signal{Int64}</span>
xsquared.value
<span class="co"># =&gt; 4</span></code></pre>
<p>The type of the lifted signal can be given as the second argument to <code>lift</code>. It is assumed to be Any if omitted.</p>
<p>Now for every value <code>x</code> takes, <code>xsquared</code> will hold its square.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">push!(x, <span class="fl">3</span>)
xsquared.value
<span class="co"># =&gt; 9</span></code></pre>
<p><code>lift</code> can take more than one signal as argument.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">y = lift((a, b) -&gt; a + b, <span class="dt">Int</span>, x, xsquared)
y.value
<span class="co"># =&gt; 12</span></code></pre>
<p><strong>Example: A stupid line-droid</strong></p>
<p>In the examples below we explore how a simple line-follower robot could be programmed with Reactive.</p>
<p>Here are the specifications of the robot:</p>
<ol type="1">
<li>There are 3 sensors: left, middle and right</li>
<li>There are 2 DC motors: left and right (the bot is balanced by a castor wheel)</li>
</ol>
<p>We start off by creating a signal of sensor values.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># the values signify how much of the line each sensor (left, middle, right) is seeing</span>
sensor_input = Input([<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">0.0</span>])     <span class="co"># :: Input{Vector{Float64}}</span></code></pre>
<p>Then create motor voltages from sensor readings.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">
<span class="kw">function</span> v_left(sensors)
   <span class="co"># slow down when left sensor is seeing a lot of the line</span>
   <span class="co"># -ve voltage turns the wheel backwards</span>
   <span class="co"># this could, of course, be [more complicated than this](http://www.societyofrobots.com/member_tutorials/book/export/html/350).</span>
   sensors[<span class="fl">2</span>] - sensors[<span class="fl">1</span>]
<span class="kw">end</span>

<span class="co"># Similarly</span>
<span class="kw">function</span> v_right(sensors)
   <span class="co"># slow down when the right sensor is seeing the line</span>
   sensors[<span class="fl">2</span>] - sensors[<span class="fl">3</span>]
<span class="kw">end</span>

left_motor  = lift(v_left,  <span class="dt">Float64</span>, sensor_input)
right_motor = lift(v_right, <span class="dt">Float64</span>, sensor_input)</code></pre>
<p>The <code>@lift</code> macro makes this simpler:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">left_motor  = @lift sensor_input[<span class="fl">1</span>] - sensor_input[<span class="fl">3</span>]
right_motor = @lift sensor_input[<span class="fl">1</span>] - sensor_input[<span class="fl">2</span>]</code></pre>
<p>We now ask the bot to apply the voltages across its two wheels:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="kw">function</span> set_voltages(left, right)
    write(LEFT_MOTOR_OUTPUT,  left)
    write(RIGHT_MOTOR_OUTPUT, right)
<span class="kw">end</span>

@lift set_voltages(left_motor, right_motor)</code></pre>
<h2 id="the-event-loop">The Event Loop</h2>
<p>Finally, we need to set up a loop which reads input from the sensors and plumbs it into the data flow we created above.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="kw">function</span> read_sensors()
    [read(LEFT_SENSOR_PIN),
     read(MIDDLE_SENSOR_PIN),
     read(RIGHT_SENSOR_PIN)]
<span class="kw">end</span>

<span class="kw">while</span> true
    <span class="co"># push! changes the value held by an input signal and</span>
    <span class="co"># propagates it through the data flow</span>
    @async push!(sensor_input, read_sensors())
    sleep(<span class="fl">0.1</span>)
<span class="kw">end</span></code></pre>
<p>See <a href="#timed-signals-and-sampling">Timed signals and sampling</a> for a more elegant way of doing the same!</p>
<h2 id="maintaining-state">Maintaining State</h2>
<p><strong>Example: A Voting System</strong> The following examples deal with a voting system in an election. The voters can either vote for Alice, Bob, or cast an invalid vote.</p>
<p><a href="api.html#foldl"><code>foldl</code></a> can be used to accumulate a value over time. You might count the number of votes like this:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">votes   = Input(:NoVote)    <span class="co"># We use :NoVote to denote the initial case</span>
total   = foldl((acc, vote) -&gt; acc + <span class="fl">1</span>, <span class="fl">0</span>, votes) <span class="co"># Count all votes</span>
alice   = foldl((acc, vote) -&gt; acc + (vote == :Alice), <span class="fl">0</span>, votes)
bob     = foldl((acc, vote) -&gt; acc + (vote == :Bob),   <span class="fl">0</span>, votes)
leading = lift((a, b) -&gt; <span class="kw">if</span> a &gt; b ? :Alice : a &lt; b ? :Bob : :Tie, alice, bob)</code></pre>
<p>Maintaining a difference between two updates is a bit more involved. To find the difference between previous and current value of a signal, you'd do:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="kw">function</span> difference(prev, x)
    prev_diff, prev_val = prev
    <span class="co"># x becomes prev_val in the next call</span>
    <span class="kw">return</span> (x-prev_val, x)
<span class="kw">end</span>

diff = lift(x-&gt;x[<span class="fl">1</span>], foldl(difference, <span class="fl">0.0</span>, signal))</code></pre>
<p>Note that this method has the advantage that all state is explicit. You could accomplish this by using a global variable to store <code>prev_val</code>, but that is not recommended.</p>
<h2 id="filter-and-merge">Filter and merge</h2>
<p>The <a href="api.html#filter"><code>filter</code></a> or <a href="api.html#dropif"><code>dropif</code></a> functions can filter a signal based on a predicate function.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># Create a signal of only valid votes</span>
<span class="co"># If the initial votes are invalid, we use :NoVote</span>
valid_votes = filter(x -&gt; x != :Invalid, :NoVote, votes)

<span class="co"># Or</span>
valid_votes = dropif(x -&gt; x == :Invalid, :NoVote, votes)</code></pre>
<p>To drop certain updates to a signal you can use <a href="api.html#keepwhen"><code>keepwhen</code></a> and <a href="api.html#dropwhen"><code>dropwhen</code></a>. You could stop collecting votes when there is a security breach like this:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">secure_votes = keepwhen(everything_secure, votes)

<span class="co"># Or</span>
secure_votes = dropwhen(security_breached, votes)</code></pre>
<p><a href="api.html#merge"><code>merge</code></a> merges multiple signals of the same type. To collect all votes from 3 polls into a single signal you'd do something like</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">votes = merge(poll1_votes, poll2_votes, poll3_votes)</code></pre>
<p>You can drop repeated updates to a signal with <a href="api.html#droprepeats"><code>droprepeats</code></a>:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">leading_norepeat = droprepeats(leading)</code></pre>
<p><code>leading_norepeat</code> only updates when the leading candidate changes.</p>
<p>Finally,</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia">lift(show_on_TV, alice, bob, stats)</code></pre>
<h2 id="timed-signals-and-sampling">Timed signals and sampling</h2>
<p>The <a href="api.html#timing"><code>Reactive.Timing</code></a> module contains some functions to create timed signals. <a href="api.html#every"><code>every</code></a> can be used to create a signal that updates at a certain interval.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>

every10secs = every(<span class="fl">10.0</span>)</code></pre>
<p><code>every10secs</code> is a signal of timestamps (Float64) which updates every 10 seconds.</p>
<p><a href="api.html#sampleon"><code>sampleon</code></a> function takes two signals and samples the second signal when the first one changes.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>

<span class="co"># Update to the leading candidate every 10 seconds</span>
periodic_leading = sampleon(every10secs, leading)</code></pre>
<p>While <code>every</code> guarrantees the interval, <a href="api.html#fps"><code>fps</code></a> tries to update at a certain maximum rate.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>

fps10 = fps(<span class="fl">10.0</span>)</code></pre>
<p>We can use <code>fps</code> to simplify the <a href="#the-event-loop">event loop</a> in our robot example above:</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># fps returns the time delta between the past two frames</span>
<span class="co"># This could be useful in animations or plotting. We ignore it here.</span>
sensor_input = lift((delta) -&gt; read_sensors(), fps(<span class="fl">10.0</span>))</code></pre>
<p><a href="api.html#fpswhen"><code>fpswhen</code></a> takes a boolean signal as the first argument and stops the timer when this signal becomes false.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># assume circuit completes if none of the sensors can see the line</span>
circuit_not_complete = lift(s -&gt; sum(s) != <span class="fl">0.0</span>, sensor_inputs)
sensor_input = lift(read_sensors, fpswhen(circuit_not_complete, <span class="fl">10.0</span>))</code></pre>
<p>this stops reading the input (and hence moving the bot) when the circuit is complete.</p>
<p><a href="api.html#timestamp"><code>timestamp</code></a> function can be used to timestamp any signal.</p>
<pre class="sourceCode julia julia" execute="false"><code class="sourceCode julia"><span class="co"># E.g.</span>
timestamped_votes = timestamp(votes)</code></pre>
<p><code>timestamped_votes</code> is a signal of <code>(timestamp, vote)</code> where <code>timestamp</code> is a <code>Float64</code> timestamp denoting when the <code>vote</code> came in.</p>
<h1 id="possible-uses">Possible uses</h1>
<p>I am currently using Reactive to build interactive widgets on <a href="http://github.com/JuliaLang/IJulia.jl">IJulia</a>. Reactive is aimed at making event-driven programming simple. You could use Reactive to build:</p>
<ul>
<li>Interactive user interfaces (watch out for <a href="https://github.com/shashi/Interact.jl">Interact.jl</a>)</li>
<li>Animations</li>
<li>Robotics and automation</li>
<li>Queueing systems and service-oriented apps</li>
</ul>
<h1 id="reporting-bugs">Reporting Bugs</h1>
<p>Let me know about any bugs, counterintuitive behavior, or enhancements you'd like by <a href="https://github.com/shashi/Reactive.jl/issues/new">filing a bug</a> on github.</p>
        <hr>
      </div>
      </div>

      <div class="col-sm-offset-8" style="z-index: 2">
        <div id="table-of-contents">
          <div id="table-of-contents-content">
            <input class="search" placeholder="SEARCH" />
            <ul class="toc list nav"><li>
                <a class="toc-item toc-current-doc" href="index.html">Introduction - Reactive.jl</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#getting-started">Getting Started</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#a-tutorial-introduction">A Tutorial Introduction</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#signals">Signals</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#do-you-even-lift">Do you even lift?</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#the-event-loop">The Event Loop</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#maintaining-state">Maintaining State</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#filter-and-merge">Filter and merge</a>
            </li>
            <li>
                <a style="margin-left: 1.0em" class="toc-item" href="#timed-signals-and-sampling">Timed signals and sampling</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#possible-uses">Possible uses</a>
            </li>
            <li>
                <a style="margin-left: 0.5em" class="toc-item" href="#reporting-bugs">Reporting Bugs</a>
            </li>
            <li>
                <a class="toc-item" href="api.html">API</a>
            </li>
            </ul>

            <script>
                var toclist = new List("table-of-contents",
                                       {valueNames: ["toc-item"]})

                $("body").scrollspy({target: "#table-of-contents"});

                $("#table-of-contents li").on("activate.bs.scrollspy",
                    function(event) {
                        $("#table-of-contents ul").find("a").css({"font-weight": "normal"});
                        $(this).children("a").css({"font-weight": "bolder"});
                    });
            </script>
          </div>
        </div>
      </div>
    </div>

  <footer class="col-sm-8">
    <p class="muted">Last modified by Shashi Gowda on Thu Aug 28 22:19:02 IST 2014. Generated with
    <a href="https://github.com/dcjones/Judo.jl">Judo</a>.</p>
  </footer>

  </div>
</body>
</html>

